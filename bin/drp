#!/usr/bin/env python
# encoding: utf-8
#

import os
import pathlib
import shutil
from typing import Tuple

import click
import cloup
from cloup.constraints import mutually_exclusive, RequireExactly, IsSet, If

from lvmdrp.functions.run_drp import run_drp, reduce_file, check_daily_mjd
from lvmdrp.functions.skyMethod import configureSkyModel_drp
from lvmdrp.utils.metadata import get_frames_metadata, get_master_metadata

from lvmdrp.functions.run_quickdrp import quick_science_reduction
from lvmdrp.functions.run_twilights import reduce_twilight_sequence, MASK_BANDS

from sdss_access import Access


class IntRangeType(click.ParamType):
    name = 'int_list'

    def convert(self, value, param, ctx):
        try:
            # Split the input value by commas
            if isinstance(value, str):
                parts = value.split(',')
            else:
                parts = value

            if len(parts) == 1:
                # If only one part, treat it as a single integer
                return [int(parts[0])]
            elif len(parts) == 2:
                # If two parts, treat them as initial and final values for a range
                start, end = map(int, parts)
                return list(range(start, end + 1))

            self.fail(f'{value} is not a valid input', param, ctx)

        except ValueError:
            self.fail(f'{value} is not a valid input', param, ctx)


class WaveRange(click.ParamType):
    name = 'wave_ranges'

    def convert(self, value, param, ctx):
        try:
            # Split the input value by commas
            if isinstance(value, str):
                waves = value.split(',')
            else:
                waves = value

            if len(waves) == 2:
                # Only if two parts, treat them as initial and final values for a range
                return tuple(map(float, waves))

            self.fail(f'{value} is not a valid input', param, ctx)

        except ValueError:
            self.fail(f'{value} is not a valid input', param, ctx)


@click.group('drp', short_help='CLI for the LVM data reduction')
def cli():
    pass


@cloup.command(short_help='Run the DRP reduction', show_constraints=True)
@click.option('-m', '--mjd', type=int, help='an MJD to reduce')
@click.option('-l', '--mjd-list', type=int, multiple=True, help='a list of specific MJDs to reduce')
@click.option('-r', '--mjd-range', type=str, help='a range of MJDs to reduce')
@click.option('--with-cals', is_flag=True, default=False, help='Flag to include indiviual calibration frames')
@click.option('--no-sci', is_flag=True, default=False, help='Flag to exclude science frame reductions')
@click.option('-e', '--expnum', type=int, help='an exposure number to reduce')
@click.option('-el', '--exp-list', type=int, multiple=True, help='a list of specific exposures to reduce')
@click.option('-er', '--exp-range', type=str, help='a range of exposure numbers to reduce')
@cloup.constraint(mutually_exclusive, ['mjd', 'mjd_list', 'mjd_range'])
@cloup.constraint(RequireExactly(1), ['mjd', 'mjd_list', 'mjd_range'])
@cloup.constraint(mutually_exclusive, ['expnum', 'exp_list', 'exp_range'])
def run(mjd, mjd_list, mjd_range, with_cals, no_sci, expnum, exp_list, exp_range):
    """ Run the DRP reduction for a given MJD or range of MJDs

    Run the DRP for an MJD or range of MJDs.  Various flags and options are available
    for filtering on calibration or science frames, or specific exposures.

    """
    mjd = mjd or mjd_list or mjd_range
    expnum = expnum or exp_list or exp_range
    run_drp(mjd=mjd, expnum=expnum, no_sci=no_sci, with_cals=with_cals)


# register full DRP command
cli.add_command(run)


@cli.command('check', short_help='Check for daily run of the DRP at Utah')
@click.option('-t', '--test', is_flag=True, default=False, help='Test the check without running the DRP')
@click.option('--with-cals', is_flag=True, default=False, help='Flag to include indiviual calibration frames')
def check_daily(test, with_cals):
    """ Checks the current MJD and starts the DRP

    Checks the current daily MJD againt the Utah data transfer, and if
    complete, starts the DRP run at Utah.

    """
    check_daily_mjd(test=test, with_cals=with_cals)


@cli.command('reduce_file', short_help='Reduce a single file')
@click.option('-f', '--filename', type=str, help='a full path filename to reduce')
def run_reduce_file(filename):
    """ Run a single raw sdR frame file through the LVM DRP """
    reduce_file(filename)


@click.group('sky', short_help='Run routines related to sky subtraction')
def skycli():
    pass


@skycli.command('configure', short_help='Configure the ESO sky routines')
@click.option('-l', '--library', is_flag=True, default=False, show_default=True,
              help='Flag to run ESO routines to build a spectral library')
@click.option('-m', '--multiscat', is_flag=True, default=False, show_default=True,
              help='Flag to run ESO "estmultiscat" routine for multiple scattering corrections')
def sky_configure(library, multiscat):
    """ Run the sky module configuration """
    configureSkyModel_drp(run_libary=library, run_multiscat=multiscat)


cli.add_command(skycli)


@click.group('metadata', short_help='Run routines related to frame metadata')
def metacli():
    pass


@cloup.command('regenerate', short_help='Regenerate the frames metadata file')
@click.option('-m', '--mjd', type=int, help='the MJD to regenerate the metadata for')
@click.option('-a', '--masters', is_flag=True, default=False, help='Flag to regenerate the masters metadata')
@cloup.constraint(If(~IsSet('masters'), then=RequireExactly(1)), ['mjd'])
def regen(mjd: int, masters: bool):
    """ Regenerate the raw or master frames metadata file """
    if masters:
        get_master_metadata(overwrite=True)
    else:
        get_frames_metadata(mjd=mjd, overwrite=True)


metacli.add_command(regen)

cli.add_command(metacli)


@click.command(short_help='Run the Quick DRP')
@click.option('-e', '--expnum', type=int, help='an exposure number to reduce')
@click.option('-f', '--use-fiducial-master', is_flag=True, default=False, help='use fiducial master calibration frames')
@click.option('-s', '--skip-sky-subtraction', is_flag=True, help='skip sky subtraction')
@click.option('--sky-weights', type=(float, float), default=None, help='weights (east, west) for the master sky combination')
@click.option('-c', '--skip-flux-calibration', is_flag=True, default=False, help='skip flux calibration')
@click.option('-n', '--ncpus', type=int, default=None, help='number of CPUs to use during extraction')
@click.option("-a", "--aperture-extraction", is_flag=True, default=False, help="run quick reduction with aperture extraction")
def quick_reduction(expnum: int, use_fiducial_master: bool, skip_sky_subtraction: bool,
                    sky_weights: tuple, skip_flux_calibration: bool, ncpus: int, aperture_extraction: bool) -> None:
    quick_science_reduction(expnum, use_fiducial_master, skip_sky_subtraction,
                            sky_weights, skip_flux_calibration, ncpus, aperture_extraction)


# register quick DRP command
cli.add_command(quick_reduction)


@click.command('twilight', short_help='Run the twilight sequence reduction')
@click.option('-e', '--expnums', type=IntRangeType(), multiple=True, help='a list of exposure numbers to reduce')
@click.option('-b', '--median-box', type=int, default=5, help='the median box size')
@click.option('-n', '--niter', type=int, default=1000, help='the number of iterations')
@click.option('-t', '--threshold', type=tuple, default=(0.5,2.0), help='the thresholds (lower,upper) for the sigma clipping')
@click.option('-k', '--nknots', type=int, default=80, help='the number of knots for the spline')
@cloup.option_group(
    'Channel masks',
    'Options for masking wavelength ranges for each spectrograph channel',
    cloup.option('--b-mask', type=WaveRange(), default=MASK_BANDS["b"], multiple=True, help='the wavelength ranges to mask for b channel'),
    cloup.option('--r-mask', type=WaveRange(), default=MASK_BANDS["r"], multiple=True, help='the wavelength ranges to mask for r channel'),
    cloup.option('--z-mask', type=WaveRange(), default=MASK_BANDS["z"], multiple=True, help='the wavelength ranges to mask for z channel')
)
@click.option('-s', '--skip-done', is_flag=True, default=False, help='Flag to skip reduction steps that have already been done')
@click.option('-d', '--display-plots', is_flag=True, default=False, help='Flag to display the plots')
def twilight_reduction(expnums: list, median_box: int, niter: int, threshold: Tuple[float,float],
                       nknots: int, b_mask: list, r_mask: list, z_mask: list, skip_done: bool,
                       display_plots: bool) -> None:
    """ Run the twilight sequence reduction """
    # parse multiple exposure number lists into a single list
    expnums = [expnum for expnum_list in expnums for expnum in expnum_list]
    reduce_twilight_sequence(
        expnums=expnums,
        median_box=median_box,
        niter=niter,
        threshold=threshold,
        nknots=nknots,
        b_mask=b_mask,
        r_mask=r_mask,
        z_mask=z_mask,
        skip_done=skip_done,
        display_plots=display_plots)


# register twilight sequence reduction
cli.add_command(twilight_reduction)


@cli.command('erase', short_help='Remove the DRP reductions')
@click.option('-d', '--drpver', type=str, help='the DRP version', required=True)
def erase(drpver: str):
    """ Clean out the DRP reductions for a given version """
    path = pathlib.Path(os.getenv('LVM_SPECTRO_REDUX')) / drpver
    if not path.exists():
        click.echo(f'Path {path} does not exist.')
        return
    shutil.rmtree(path)


@cli.command(short_help='Download the master calibrations')
@click.option('-k', '--kind', type=str, default='*', help='the kind of files to download, e.g "pixmask".', show_default=True)
@click.option('-m', '--mjd', type=str, default='*', help='the MJD folder to download', show_default=True)
@click.option('-c', '--camera', type=str, default='*', help='the camera to download, e.g. "b*" or "b1".', show_default=True)
def get_calibs(kind, mjd, camera):
    """ Download the master calibration frames

    Downloads the master calibration frames from the Utah SAS in LVM_SANDBOX/calib.  This command
    only downloads files when they do not yet exist on your local system or when the remote files
    are newer.

    The syntax for the calibration files are $LVM_SANDBOX/calib/[mjd]/lvm-m[kind]-[camera].fits.
    "mjd" is the MJD directory to download. "kind" is the kind of calib file to download, e.g. pixmask,
    bias, fiberflat, without the leading "m".  "camera" is the camera, can be a specific channel, e.g "b1"
    or all channels with "b*".

    """
    a = Access()
    a.remote()
    a.add('lvm_calib', kind=kind, mjd=mjd, camera=camera)
    a.set_stream()
    a.commit()



if __name__ == "__main__":
    cli()
