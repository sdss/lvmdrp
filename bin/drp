#!/usr/bin/env python
# encoding: utf-8
#

import os
import pathlib
import shutil
from itertools import groupby

import click
import cloup
from cloup.constraints import mutually_exclusive, RequireExactly, IsSet, If

from lvmdrp.main import run_drp, reduce_file, check_daily_mjd, parse_mjds
from lvmdrp.functions.skyMethod import configureSkyModel_drp
from lvmdrp.utils.metadata import get_frames_metadata, get_master_metadata
from lvmdrp.utils.cluster import run_cluster

from lvmdrp.functions.run_calseq import (
    reduce_nightly_sequence,
    reduce_longterm_sequence,
    fix_raw_pixel_shifts)

from sdss_access import Access


class IntListType(click.ParamType):
    name = 'int_list'

    def convert(self, value, param, ctx):
        try:
            # Split the input value by commas
            if isinstance(value, str):
                parts = value.split(',')
            else:
                parts = value

            return [int(part) for part in parts]

        except ValueError:
            self.fail(f'{value} is not a valid input', param, ctx)


class IntRangeType(click.ParamType):
    name = 'int_ranges'

    def convert(self, value, param, ctx):
        try:
            # Split the input value by commas
            if isinstance(value, str):
                parts = value.split(',')
            else:
                parts = value

            if len(parts) == 1:
                # If only one part, treat it as a single integer
                return [int(parts[0])]
            elif len(parts) == 2:
                # If two parts, treat them as initial and final values for a range
                start, end = map(int, parts)
                return list(range(start, end + 1))

            self.fail(f'{value} is not a valid input', param, ctx)

        except ValueError:
            self.fail(f'{value} is not a valid input', param, ctx)


class WaveRange(click.ParamType):
    name = 'wave_ranges'

    def convert(self, value, param, ctx):
        try:
            # Split the input value by commas
            if isinstance(value, str):
                waves = value.split(',')
            else:
                waves = value

            if len(waves) == 2:
                # Only if two parts, treat them as initial and final values for a range
                return tuple(map(float, waves))

            self.fail(f'{value} is not a valid input', param, ctx)

        except ValueError:
            self.fail(f'{value} is not a valid input', param, ctx)


@click.group('drp', short_help='CLI for the LVM data reduction')
def cli():
    pass


@cloup.command(short_help='Run the DRP reduction', show_constraints=True)
@click.option('-m', '--mjd', type=int, help='an MJD to reduce')
@click.option('-l', '--mjd-list', type=int, multiple=True, help='a list of specific MJDs to reduce')
@click.option('-r', '--mjd-range', type=str, help='a range of MJDs to reduce')
@click.option('--with-cals', is_flag=True, default=False, help='Flag to include indiviual calibration frames')
@click.option('--no-sci', is_flag=True, default=False, help='Flag to exclude science frame reductions')
@click.option('-e', '--expnum', type=int, help='an exposure number to reduce')
@click.option('-el', '--exp-list', type=int, multiple=True, help='a list of specific exposures to reduce')
@click.option('-er', '--exp-range', type=str, help='a range of exposure numbers to reduce')
@click.option('-f', '--skip-fluxcal', is_flag=True, default=False, help='skip flux calibration')
@click.option('-c', '--clean-ancillary', is_flag=True, default=False, help='Remove ancillary paths after run')
@click.option('-d', '--debug-mode', is_flag=True, default=False, help='Set debug mode on to run using aperture extraction and skip CR rejection')
@cloup.constraint(mutually_exclusive, ['mjd', 'mjd_list', 'mjd_range'])
@cloup.constraint(RequireExactly(1), ['mjd', 'mjd_list', 'mjd_range'])
@cloup.constraint(mutually_exclusive, ['expnum', 'exp_list', 'exp_range'])
def run(mjd, mjd_list, mjd_range, with_cals, no_sci, expnum, exp_list, exp_range, skip_fluxcal, clean_ancillary, debug_mode):
    """ Run the DRP reduction for a given MJD or range of MJDs

    Run the DRP for an MJD or range of MJDs.  Various flags and options are available
    for filtering on calibration or science frames, or specific exposures.

    """
    mjd = mjd or mjd_list or mjd_range
    expnum = expnum or exp_list or exp_range
    run_drp(mjd=mjd, expnum=expnum, no_sci=no_sci, with_cals=with_cals,
            skip_fluxcal=skip_fluxcal, clean_ancillary=clean_ancillary,
            debug_mode=debug_mode)


# register full DRP command
cli.add_command(run)


@cli.command('check', short_help='Check for daily run of the DRP at Utah')
@click.option('-t', '--test', is_flag=True, default=False, help='Test the check without running the DRP')
@click.option('--with-cals', is_flag=True, default=False, help='Flag to include indiviual calibration frames')
def check_daily(test, with_cals):
    """ Checks the current MJD and starts the DRP

    Checks the current daily MJD againt the Utah data transfer, and if
    complete, starts the DRP run at Utah.

    """
    check_daily_mjd(test=test, with_cals=with_cals)


@cli.command('reduce_file', short_help='Reduce a single file')
@click.option('-f', '--filename', type=str, help='a full path filename to reduce')
def run_reduce_file(filename):
    """ Run a single raw sdR frame file through the LVM DRP """
    reduce_file(filename)


@click.group('sky', short_help='Run routines related to sky subtraction')
def skycli():
    pass


@skycli.command('configure', short_help='Configure the ESO sky routines')
@click.option('-l', '--library', is_flag=True, default=False, show_default=True,
              help='Flag to run ESO routines to build a spectral library')
@click.option('-m', '--multiscat', is_flag=True, default=False, show_default=True,
              help='Flag to run ESO "estmultiscat" routine for multiple scattering corrections')
def sky_configure(library, multiscat):
    """ Run the sky module configuration """
    configureSkyModel_drp(run_libary=library, run_multiscat=multiscat)


cli.add_command(skycli)


@click.group('metadata', short_help='Run routines related to frame metadata')
def metacli():
    pass


@cloup.command('regenerate', short_help='Regenerate the frames metadata file')
@click.option('-m', '--mjd', type=int, help='the MJD to regenerate the metadata for')
@click.option('-a', '--masters', is_flag=True, default=False, help='Flag to regenerate the masters metadata')
@cloup.constraint(If(~IsSet('masters'), then=RequireExactly(1)), ['mjd'])
def regen(mjd: int, masters: bool):
    """ Regenerate the raw or master frames metadata file """
    if masters:
        get_master_metadata(overwrite=True)
    else:
        get_frames_metadata(mjd=mjd, overwrite=True)


metacli.add_command(regen)

cli.add_command(metacli)


@cli.command('nightly-cals', short_help='Run the nightly calibration sequence')
@click.option('-m', '--mjd', type=int, help='an MJD to reduce')
@click.option('-l', '--mjd-list', type=int, multiple=True, help='a list of specific MJDs to reduce')
@click.option('-r', '--mjd-range', type=str, help='a range of MJDs to reduce')
@click.option('-c', '--skip-cr', is_flag=True, default=False, help='flag to skip cosmic rays rejection')
@click.option('-n', '--use-nightly-cals', is_flag=True, default=False, help='flag to use nightly calibrations instead of fiducial ones')
@click.option('-b', '--skip-bias', is_flag=True, default=False, help='skip bias calibrations')
@click.option('-t', '--skip-trace', is_flag=True, default=False, help='skip fiber traces')
@click.option('-w', '--skip-wavelength', is_flag=True, default=False, help='skip wavelength calibrations')
@click.option('-d', '--skip-dome', is_flag=True, default=False, help='skip dome fiberflats')
@click.option('-f', '--skip-twilight', is_flag=True, default=False, help='skip twilight fiberflats')
@click.option('-s', '--skip-done', is_flag=True, default=False, help='flag to skip reduction steps that have already been done')
@click.option('-a', '--keep-ancillary', is_flag=True, default=False, help='flag to keep ancillary files')
@cloup.constraint(mutually_exclusive, ['mjd', 'mjd_list', 'mjd_range'])
@cloup.constraint(RequireExactly(1), ['mjd', 'mjd_list', 'mjd_range'])
def nightly_calibrations(mjd, mjd_list, mjd_range, skip_cr, use_nightly_cals,
                         skip_bias, skip_trace, skip_wavelength,
                         skip_dome, skip_twilight, skip_done, keep_ancillary):
    """ Run the nightly calibration sequence """

    # NOTE: skip dome fiberflats while I fix the tracing of the amplitude
    skip_dome = True

    only_cals = {flavor for flavor, skip in zip(["bias", "trace", "wave", "dome", "twilight"],
                                                [skip_bias, skip_trace, skip_wavelength, skip_dome, skip_twilight]) if not skip}

    # parse MJDs or
    mjds = parse_mjds(mjd=mjd or mjd_list or mjd_range) or "*"
    if not isinstance(mjds, list):
        mjds = [mjds]
    for mjd in mjds:
        reduce_nightly_sequence(mjd=mjd, reject_cr=not skip_cr,
                                use_fiducial_cals=not use_nightly_cals,
                                only_cals=only_cals,
                                skip_done=skip_done, keep_ancillary=keep_ancillary)

# register nightly calibration sequence
cli.add_command(nightly_calibrations)


@cli.command('long-term-cals', short_help='Run the long-term calibration sequence')
@click.option('-m', '--mjd', type=int, required=True, help='the MJD to reduce')
@click.option('-c', '--skip-cr', is_flag=True, default=False, help='flag to skip cosmic rays rejection')
@click.option('-n', '--use-nightly-cals', is_flag=True, default=False, help='flag to use nightly calibrations instead of fiducial ones')
@click.option('-b', '--skip-bias', is_flag=True, default=False, help='skip bias calibrations')
@click.option('-t', '--skip-trace', is_flag=True, default=False, help='skip fiber traces')
@click.option('-w', '--skip-wavelength', is_flag=True, default=False, help='skip wavelength calibrations')
@click.option('-f', '--skip-fiberflat', is_flag=True, default=False, help='skip fiberflats')
@click.option('-s', '--skip-done', is_flag=True, default=False, help='flag to skip reduction steps that have already been done')
@click.option('-a', '--keep-ancillary', is_flag=True, default=False, help='flag to keep ancillary files')
def long_term_calibrations(mjd, skip_cr, use_nightly_cals,
                           skip_bias, skip_trace, skip_wavelength,
                           skip_fiberflat, skip_done, keep_ancillary):
    """ Run the long-term calibration sequence """

    only_cals = {flavor for flavor, skip in zip(["bias", "trace", "wave", "fiberflat"],
                                                [skip_bias, skip_trace, skip_wavelength, skip_fiberflat]) if not skip}
    reduce_longterm_sequence(mjd=mjd, reject_cr=not skip_cr,
                             use_fiducial_cals=not use_nightly_cals,
                             only_cals=only_cals,
                             skip_done=skip_done, keep_ancillary=keep_ancillary)

# register long-term calibration sequence
cli.add_command(long_term_calibrations)


@cli.command('fix-pixel-shifts', short_help='Fix the electronic pixel shifts in the raw data')
@click.option('-m', '--mjd', type=int, help='the MJD to reduce')
@click.option('-e', '--expnums', type=IntListType(), help='a list of exposure numbers to reduce')
@click.option('-r', '--ref-expnums', type=IntListType(), help='a list of reference exposure numbers')
@click.option('-c', '--custom-shift', type=(str, int, int), multiple=True, help='3-tuple of spectrograph, exposure and pixel row to shift from')
@click.option('-w', '--wave-widths', type=int, default=5000, help='the width of the wavelength range in angstroms')
@click.option('-y', '--y-widths', type=int, default=20, help='the width of the cross-dispersion aperture in pixels')
@click.option('-f', '--flat-spikes', type=int, default=21, help='the window within which to filter spikes')
@click.option('-t', '--threshold-spikes', type=float, default=0.6, help='the threshold for the spikes filtering')
@click.option('-i', '--interactive', is_flag=True, default=False, help='flag to run in interactive mode when QC and DRP discrepancies are found')
def fix_pixel_shifts(mjd, expnums, ref_expnums, custom_shift, wave_widths, y_widths, flat_spikes, threshold_spikes, interactive):
    """ Fix the electronic pixel shifts in the raw data """
    custom_shifts = {}
    for key, vals in groupby(custom_shift, key=lambda t: t[:2]):
        custom_shifts[key] = list(v[-1] for v in vals)

    fix_raw_pixel_shifts(mjd=mjd, expnums=expnums, ref_expnums=ref_expnums,
                         wave_widths=wave_widths, y_widths=y_widths,
                         shift_rows=custom_shifts, flat_spikes=flat_spikes,
                         threshold_spikes=threshold_spikes,
                         interactive=interactive, skip_done=True)

# register fix pixel shifts command
cli.add_command(fix_pixel_shifts)


@cli.command('erase', short_help='Remove the DRP reductions')
@click.option('-d', '--drpver', type=str, help='the DRP version', required=True)
def erase(drpver: str):
    """ Clean out the DRP reductions for a given version """
    path = pathlib.Path(os.getenv('LVM_SPECTRO_REDUX')) / drpver
    if not path.exists():
        click.echo(f'Path {path} does not exist.')
        return
    shutil.rmtree(path)


@cli.command(short_help='Download the master calibrations')
@click.option('-k', '--kind', type=str, default='*', help='the kind of files to download, e.g "pixmask".', show_default=True)
@click.option('-m', '--mjd', type=str, default='*', help='the MJD folder to download', show_default=True)
@click.option('-c', '--camera', type=str, default='*', help='the camera to download, e.g. "b*" or "b1".', show_default=True)
def get_calibs(kind, mjd, camera):
    """ Download the master calibration frames

    Downloads the master calibration frames from the Utah SAS in LVM_SANDBOX/calib.  This command
    only downloads files when they do not yet exist on your local system or when the remote files
    are newer.

    The syntax for the calibration files are $LVM_SANDBOX/calib/[mjd]/lvm-m[kind]-[camera].fits.
    "mjd" is the MJD directory to download. "kind" is the kind of calib file to download, e.g. bias,
    fiberflat, without the leading "m".  "camera" is the camera, can be a specific channel, e.g "b1"
    or all channels with "b*". The pixel masks and flats are stored at $LVM_SANDBOX/calib/pixelmasks
    and are automatically included in the download.

    """
    a = Access()
    a.remote()
    a.add('lvm_calib', kind="pix*", mjd="pixelmasks", camera=camera)
    a.add('lvm_calib', kind=kind, mjd=mjd, camera=camera)
    a.set_stream()
    a.commit()


@cli.command('cluster', short_help='Submit a Utah cluster run')
@click.option('-l', '--mjd-list', type=int, default=None, multiple=True, help='a list of specific MJDs to reduce')
@click.option('-r', '--mjd-range', type=str, default=None, help='a range of MJDs to reduce')
@click.option('-n', '--nodes', type=int, default=2, help='the number of nodes to use')
@click.option('-p', '--ppn', type=int, default=64, help='the number of CPU cores to use per node')
@click.option('-w', '--walltime', type=str, default="24:00:00", help='the time for which the job is allowed to run')
@click.option('-a', '--alloc', type=click.Choice(['sdss-np', 'sdss-kp']), default='sdss-np', help='which partition to use')
@click.option('-s', '--submit', type=bool, default=True, help='flag to submit the job or not')
def cluster(mjd_list, mjd_range, nodes, ppn, walltime, alloc, submit):
    """ Submit a Utah cluster job to batch run the DRP by MJD """

    # filter the mjds
    mjds = mjd_list or mjd_range or None
    if mjds:
        mjds = parse_mjds(mjds)

    # submit the cluster job
    run_cluster(mjds=mjds, nodes=nodes, ppn=ppn, walltime=walltime, alloc=alloc, submit=submit)


if __name__ == "__main__":
    cli()
